- [第五章 程序控制结构](#第五章-程序控制结构)
  - [流程控制](#流程控制)
  - [分支控制](#分支控制)
    - [嵌套分支](#嵌套分支)
    - [switch分支结构](#switch分支结构)
      - [switch细节讨论](#switch细节讨论)
    - [switch if分支控制比较](#switch-if分支控制比较)
  - [循环控制](#循环控制)
    - [for循环控制](#for循环控制)
      - [细节说明](#细节说明)
    - [while循环](#while循环)
    - [do-while循环](#do-while循环)
  - [多重循环](#多重循环)
    - [化繁为简、先死后活](#化繁为简先死后活)
  - [break语句](#break语句)
    - [使用细节](#使用细节)
  - [continue语句](#continue语句)
    - [使用细节](#使用细节-1)
  - [return语句](#return语句)
- [第六章 数组、排序和查找](#第六章-数组排序和查找)
  - [数组](#数组)
    - [使用细节](#使用细节-2)
  - [数组赋值机制](#数组赋值机制)
    - [值传递和引用传递区别](#值传递和引用传递区别)
    - [数组拷贝](#数组拷贝)
    - [数组反转](#数组反转)
    - [数组扩容](#数组扩容)
    - [数组排序](#数组排序)
      - [冒泡排序](#冒泡排序)
    - [查找](#查找)
  - [多维数组-二维数组](#多维数组-二维数组)
    - [使用方式1：动态初始化](#使用方式1动态初始化)
    - [使用方式2：动态初始化](#使用方式2动态初始化)
    - [使用方式3：动态初始化-列数不确定](#使用方式3动态初始化-列数不确定)
    - [使用方式4：静态初始化](#使用方式4静态初始化)
    - [声明方式](#声明方式)

# 第五章 程序控制结构
## 流程控制
- 顺序控制 ：中间没有判断和跳转
- 分支控制
- 循环控制
## 分支控制
程序有选择执行
if(){}else{}
- 单分支
- 双分支
- 多分支  if( ) { } else if () {} else{}; 可以没有else
### 嵌套分支
在一个分支结构中，又完整嵌套类另一个完整的分支，不要超过3层
### switch分支结构
```java
switch(表达式){
    case 1:
    ;
    break;

    case 2:
    ;
    break;

    default:
    ;
    break;
}
```
表达式对应一个值
- 有穿透效应
#### switch细节讨论
- 表达式数据类型应与case一致或者可转换
- 表达式返回值必须是： byte 、short 、 int 、 char、 enum(枚举)、 String
- case值必须是常量、不能是变量
- default子句是可选的，当没有匹配case时，执行default
- break语句，跳出，没有则会执行到末尾
### switch if分支控制比较
- 判断具体数值不服哦，符合byte、char、等类型
- 对区间判断，对结果布尔类型判断
## 循环控制
### for循环控制
```java
for (循环变量初始化; 循环条件; 循环变量迭代){
    循环操作；
}
```
#### 细节说明
- 初始化可以有多条初始化语句，但类型一样，中间逗号隔开，迭代也是。
化繁为简、先死后活
### while循环
```java
循环变量初始化;
while (循环条件){
    循环体（语句）;
    循环变量迭代;
}
```
### do-while循环
```java
循环变量初始化；
do {
    循环体（语句）；
    循环变量迭代；
} while(循环条件);
```
先执行再判断
## 多重循环
将一个循环放到另一个循环体内。一般两层，最多不要超过四层
### 化繁为简、先死后活
## break语句
break 用于某个语句块的执行，退出当前循环
### 使用细节
- 出现在多层嵌套语句中时，可以通过标签指明要终止哪一层语句块
- 尽量不要使用标签
## continue语句
结束本次循环，继续执行下次循环
### 使用细节
## return语句
跳出所在方法。如果写在main里，退出程序
# 第六章 数组、排序和查找
## 数组
可以存放多个同一类型的数据，是一种数据类型，引用类型。
 - 使用方式1 ：动态初始化1
     - 定义： ``` 数组名[] = new 数据类型[大小]； double[] scores = new double[5];```
     - 引用：数组名[下标/索引]
 - 使用方式2 ： 动态初始化2
    - 先声明数组，``` 数据类型[] 数组名；```
    - 创建数组，``` 数组名 = new 数据类型[大小]```
 -  使用方式3 ：静态初始化
    - 初始化数组，``` 数据类型[] 数组名 = {元素1，元素2}``` 
### 使用细节
- 数组是相同类型数据的组合
- 数组中的元素可以是任何数据类型
- 数据创建后，如果没有赋值，有默认值
    - ``` int 0; short 0; byte 0; long 0; float 0.0;  double 0.0; char \u0000; boolean false; String null```
- 下标从0开始
- 数组属引用类型，数组型数据是对象（object）
## 数组赋值机制
- 基本数据类型赋值，赋值方式为值拷贝，深拷贝，值传递
- 数组在默认情况下是引用，赋的值是地址，浅拷贝、引用传递
### 值传递和引用传递区别
jvm内存分为三部分： 栈 、堆 、方法区。 对数组而言，地址存放在栈里，地址指向内容在堆里
### 数组拷贝
- 创建一个新的数组arr2，开辟新的数据空间
- 大小为arr1.length
- 遍历arr1，把每个元素拷贝到arr2对应的元素位置
### 数组反转
### 数组扩容
实现动态的给数组添加元素效果，实现对数组扩容
- 定义初始数组arr1
- 定义一个新数组,arr1的长度+1
- 遍历arr1，并加入新数据
### 数组排序
- 内部排序：将需要处理的所有数据都加载到内部存储器进行排序，包括，交换时排序法、选择式排序法、插入式
- 外部排序：数据量过大，无法全部加载到内存中，借助外部存储排序。合并排序、直接合并排序
#### 冒泡排序
通过对排序序列从后向前，依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后面
### 查找
- 顺序查找
- 二分查找
## 多维数组-二维数组
``` int[][] arr = {}```
### 使用方式1：动态初始化
- ```类型[][] 数组名 = new 类型[大小][大小]```
### 使用方式2：动态初始化
- ``` int arr[][]; arr = new int[2][2]```先声明再创建
### 使用方式3：动态初始化-列数不确定
### 使用方式4：静态初始化
1. ``` 定义 类型 数组名[][]={{}, {}}```
### 声明方式
```int [][]y ; int[] y[]; int y[][];```

```String strs[] = new String[]{"a", "b"};```是正确的

```String strs[] = new String[2]{"a", "b"};```是错误的  


